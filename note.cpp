/*
 * 这个文件里面全部都是注释
 *
 * 我把游戏的基础逻辑实现得差不多了，主要有：
 *    1、游戏开始阶段的地图、塔
 *    2、游戏进行阶段的调兵、兵打兵、兵打塔
 *    3、胜利条件和升级（升级之后我只把新的界面打出来了，剩下的一样做就好）
 *
 * 我暂时先把它设计为一个二人对战游戏，这样稍微简单一点
 * 如果设计成玩家和电脑对战，那电脑的策略会比较复杂，所以我觉得最好先实现基础逻辑
 * 后面如果有时间，我们可以为电脑设计策略，当然，代价是电脑的出招可以完全被我们预测
 *
 *
 * 由于某些不可描述的原因，有些函数的位置和我们之前讨论的不一样：
 *    1、气和调兵函数我放到 World 类里面了
 *    2、加气函数和士兵的移动函数我放到 MW1 里面了
 *    3、所谓的 tower 和 base 分别表示那两个副塔，因为主塔性质简单，我就没有专门搞一个类
 *      这样的好处就是主塔的相关函数在 world 和 mw1 里面更容易实现和调用
 *      比如绘图函数，我到现在还没有搞清楚在 mw1 之外怎么绘图，那个 Qpainter 貌似只有在主窗口才有用
 *
 * 为了让程序跑起来更方便，省得每回都要对 vector 扫描，我直接用不同的类区分敌我了
 *    我军（或者玩家一）： soldier/base 敌军（或者玩家二）: enemy/tower
 *
 * 新游戏界面的构建方法（反正我是这么干的）：
 *    1、导入地图文件
 *    2、构建各类 RPGObj ，存储到各类的 vector 里面
 *
 * 新 RPGObj 子类的构建方法（以 soldier 为例）：
 *    1、新建头文件，源文件，该怎么写怎么写
 *    2、在 icon.cpp 里面的 make_pair 里将子类的图标确定，比如 make_pair("soldier",ICON("soldier",1,13, 1, 2)),
 *    3、在 World 成员里面新加入 vector<Soldier*> _soldier
 *    4、在 World::initWorld() 里面声明一个 soldier ，比如
 *          Soldier * p = new Soldier ;
            p->initObj("soldier") ;
            p->setPosX(7) ;
            p->setPosY(22) ;
            (*p).set_life(20);

            this->_soldier.push_back(p) ；
 *      注意不要忘了 push_back，就是把新声明的 soldier 加到 vector 里面
 *    5、在 World::show() 里加入 soldier 类
 *    6、在 World::eraseObj() 里…… 在 World::delete_world() 里……
 *
 * 迭代器：
 *    如果想对 vector 中的元素进行访问和处理，就需要生成一个迭代器
 *    迭代器可以认为是一个指针，指向 vector 中的元素
 *    如果想对 vector 中的元素一一检索，就让迭代器从第一个元素起，一直指向最后一个
 *
 * 下一版目标：
 *    1、小兵的不同出生地
 *    2、不同种类小兵
 *    3、横屏
*/
